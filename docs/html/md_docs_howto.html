<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="DoxyPress 1.3.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OZO: How to</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxypress.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by DoxyPress -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OZO
   </div>
   <div id="projectbrief">Asychronous header-only Boost.Asio-based PostgreSQL C++17 type-safe library. And yes, it is fast!</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by DoxyPress 1.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li><a href="https://github.com/yandex/ozo"><span>GitHub</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">How to </div>  </div>
  <div class="clear-floats"></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Here are some examples of how to use OZO API.</p>
<h2>How To Make A Very Simple request</h2>
<p>E.g. you have <em>very</em> simple table.</p>
<div class="fragment"><div class="line">CREATE TABLE users_info(</div><div class="line">    id          bigint  NOT NULL,</div><div class="line">    name        text,</div><div class="line">    amount      bigint  NOT NULL</div><div class="line">);</div></div><!-- fragment --><p>If you want execute just a single query with no custom types or something else then the simplest way for you is:</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line">#include &lt;ozo/request.h&gt;</div><div class="line">#include &lt;ozo/connection_info.h&gt;</div><div class="line">#include &lt;ozo/shortcuts.h&gt;</div><div class="line">#include &lt;boost/asio.hpp&gt;</div><div class="line"></div><div class="line">int main() {</div><div class="line">    // We need io_context for IO, this is alias on boost::asio::io_context</div><div class="line">    boost::asio::io_context io;</div><div class="line"></div><div class="line">    // Rows which accepts integer and nullable string columns in the sequence</div><div class="line">    // It is an alias on std::vector of std::tuple</div><div class="line">    ozo::rows_of&lt;std::int64_t, std::optional&lt;std::string&gt;&gt; rows;</div><div class="line"></div><div class="line">    // Connection info with host and port to coonect to</div><div class="line">    ozo::connection_info&lt;&gt; conn_info(&quot;host=... port=...&quot;);</div><div class="line"></div><div class="line">    // For _SQL literal</div><div class="line">    using namespace ozo::literals;</div><div class="line">    // Our query statement</div><div class="line">    const auto query = &quot;SELECT id, name FROM users_info WHERE amount&gt;=&quot;_SQL + std::int64_t(25);</div><div class="line"></div><div class="line">    // Request with connection provider, query and callback.</div><div class="line">    // Provider binds how to get connection with io_context.</div><div class="line">    ozo::request(ozo::make_provider(io, conn_info), query, ozo::into(rows),</div><div class="line">            [&amp;](ozo::error_code ec, auto conn) {</div><div class="line">        if (ec) {</div><div class="line">            // Here we got an error, so we can get:</div><div class="line">            //           error code&#39;s message</div><div class="line">            std::cerr &lt;&lt; ec.message()</div><div class="line">            //           error message from underlying libpq</div><div class="line">                    &lt;&lt; &quot; | &quot; &lt;&lt; error_message(conn)</div><div class="line">            //           and error context from OZO</div><div class="line">                    &lt;&lt; &quot; | &quot; &lt;&lt; get_error_context(conn);</div><div class="line">            return;</div><div class="line">        };</div><div class="line"></div><div class="line">        // Connection must be in good state here,</div><div class="line">        // typically you do not need to check it manually</div><div class="line">        assert(ozo::connection_good(conn));</div><div class="line"></div><div class="line">        // We got results, let&#39;s handle, e.g. print it out</div><div class="line">        std::cout &lt;&lt; &quot;id&quot; &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;name&quot; &lt;&lt; std::endl;</div><div class="line">        for(auto&amp; row: res) {</div><div class="line">            std::cout &lt;&lt; std::get&lt;0&gt;(row) &lt;&lt; &#39;\t&#39;</div><div class="line">                    &lt;&lt; std::get&lt;1&gt;(row) &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">    });</div><div class="line"></div><div class="line">    io.run();</div><div class="line">}</div></div><!-- fragment --><p>Let's look a little bit closer on this pretty simple asynchronous code.</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line">ozo::rows_of&lt;std::int64_t, std::optional&lt;std::string&gt;&gt; rows;</div></div><!-- fragment --><p>Here we define result type as we want to see it. Practically <code>ozo::rows_of</code> is an alias on <code>std::vector&lt;std::tuple&lt;...&gt;&gt;</code>. And <code>ozo::into</code> is an alias on <code>std::back_inserter</code>. So <code>request()</code> function will fill this vector of tuples according to the database response rows.</p>
<p>It is <em>very important</em> to preserve the same order of fields in request and types in the tuple (it is a little bit annoying, but there is a way to avoid it via <a href="https://www.boost.org/doc/libs/1_66_0/libs/hana/doc/html/index.html#tutorial-introspection-adapting">Boost.Hana</a> or <a href="https://www.boost.org/doc/libs/1_66_0/libs/fusion/doc/html/fusion/adapted.html">Boost.Fusion</a> structure adaptation).</p>
<p>There is <code>std::optional&lt;std::string&gt;</code> at the second position of the tuple. This is because <code>name</code> field of the table can be <em>NULL</em>. Empty optional represens the <em>NULL</em> (learn more about Nullable concept). If you ommit an <code>std::optional</code> then in case of <em>NULL</em> value run-time result deserialization error will happend.</p>
<p>The first argument of the tuple can not be a <em>NULL</em>, so here we do not to bother about it and can ommit <code>std::optional</code>.</p>
<p>There is no mistake to expect nullable type for non-nullable result, but the opposite leads to run-time error in case of <em>NULL</em> value result from database.</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line">ozo::connection_info&lt;&gt; conn_info(&quot;host=... port=...&quot;);</div></div><!-- fragment --><p>Now we need to create a connection information for database to connect to. This is our connection provider which can create a connection for us as it will be needed (see more information about connection provider and how to get connection).</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line">const auto query = &quot;SELECT id, name FROM users_info WHERE amount&gt;=&quot;_SQL + std::int64_t(25);</div></div><!-- fragment --><p>Here our query for database. There is a text with <code>_SQL</code> literal and single parameter <code>std::int64_t(25)</code>. Note, what the parameter will be passed as a separate binary parameter but not as a part of query text.</p>
<p>Here is <code>request()</code> asynchronous function call.</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line">ozo::request(ozo::make_provider(io, conn_info), query, ozo::into(res),</div><div class="line">        [&amp;](ozo::error_code ec, auto conn) {</div><div class="line">//...</div><div class="line">});</div></div><!-- fragment --><p><code>ozo::make_provider(io, conn_info)</code> - the first parameter is a <b>Connection Provider</b> or <b>Connection</b>. <b>Connection Provider</b> is an entity from which you can get a new (or may be already established) connection. <b>Connection</b> is a <b>Connection Provider</b> since it can provide itself. So the query request will be performed within connection obtained for the first argument.</p>
<p><code>query</code> - the next argument is query which we discussed earler.</p>
<p><code>ozo::into(res)</code> - the output perameter. In this case out parameter is back inserter iterator to the result vector. Note, what the life time of the output parameter managed by the user. In this case it correctly placed on stack since its lifetime overlaps <code>io.run()</code> call. But in more sophisticated code with callbacks it needs to be stored e.g. in shared pointer or something like this. The query output parameter can be iterator on container with appropriated data items, or it can be <code>ozo::result</code> which provides access to raw binary data. The second variant is not recommended since user must implement binary protocol parsing by self, but if it needed it can be used.</p>
<p><code>[&amp;](ozo::error_code ec, auto conn)</code> - completion token parameter, in this case is callback lambda. In other cases it can be <a href="https://www.boost.org/doc/libs/1_67_0/doc/html/boost_asio/reference/use_future.html">boost::asio::use_future</a>, <a href="https://www.boost.org/doc/libs/1_67_0/doc/html/boost_asio/reference/yield_context.html">boost::asio::yield_context</a> or any other <a href="https://www.boost.org/doc/libs/1_67_0/doc/html/boost_asio/reference/async_result.html">boost::asio::async_result</a> comatible <a href="https://www.boost.org/doc/libs/1_67_0/doc/html/boost_asio/reference/async_completion.html">Completion Token</a>. The arguments of the call back are error code <code>ec</code> (which is namely <code>boost::system::error_code</code> for now) and the connection <code>conn</code> with which the query was made. Even if you got an error it is possible what there is an additional error context in the <code>conn</code>. Since there is no rooms to place context depended information about connection error into error code the context depended information provided via <code><a class="el" href="group__Connection__Api.html#gae1d570854c32a38adcad99baf73e0baa" title="Gives native libpq error message. ">error_message()</a></code> and <code><a class="el" href="group__Connection__Api.html#ga3b48ff27d7b2258c853a422382ef8e6a" title="Gives additional error context from OZO. ">get_error_context()</a></code> functions. The first one returns error message from <code>libpq</code>, the second - additional context from <code>OZO</code>.</p>
<p><code>for(auto&amp; row: res)</code> - so if there is no error we can handle result from the output container.</p>
<h2>How Start To Do Not Bother With Types Sequence In Row But Begin To Bother About Column Names</h2>
<p>In previous story we saw how to do a simple request. But there is a tricky thing with sequence of types in result: </p><div class="fragment"><div class="line"> {c++}</div><div class="line">ozo::rows_of&lt;std::int64_t, std::optional&lt;std::string&gt;&gt; rows;</div><div class="line"></div><div class="line">//...</div><div class="line"></div><div class="line">const auto query = &quot;SELECT id, name FROM users_info WHERE amount&gt;=&quot;_SQL + std::int64_t(25);</div></div><!-- fragment --><p>If we interchange <code>id</code> and <code>name</code> in the query text we will get a run-time error. To be more robust for such changes there is another way - adaptation. E.g. with Boost.Fusion.</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line">BOOST_FUSION_DEFINE_STRUCT((), my_row,</div><div class="line">    (std::int64_t, id)</div><div class="line">    (std::optional&lt;std::string&gt;, name)</div><div class="line">)</div><div class="line"></div><div class="line">int main() {</div><div class="line"></div><div class="line">//...</div><div class="line"></div><div class="line">    std::vector&lt;my_row&gt; res;</div><div class="line"></div><div class="line">//...</div><div class="line"></div><div class="line">    const auto query = &quot;SELECT id, name FROM users_info WHERE amount&gt;=&quot;_SQL + std::int64_t(25);</div><div class="line"></div><div class="line">    ozo::request(ozo::make_provider(io, conn_info), query, ozo::into(res),</div><div class="line">            [&amp;](ozo::error_code ec, auto conn) {</div><div class="line">    //...</div><div class="line">    });</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>In this case you can change fields' places free. Fields and structure members are bound with thier names.</p>
<h2>How To Determine Which Type I need To Use For The PostgreSQL Type</h2>
<p>It is a good question! Since we are using binary protocol and have serialization/deserialization system we also have a type system. It is easy and extandable. For build-in types you can look at <a href="../include/ozo/type_traits.h">ozo/type_traits.h</a> for difinitions like:</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line">OZO_PG_DEFINE_TYPE(std::vector&lt;char&gt;, &quot;bytea&quot;, BYTEAOID, dynamic_size)</div><div class="line"></div><div class="line">OZO_PG_DEFINE_TYPE_AND_ARRAY(boost::uuids::uuid, &quot;uuid&quot;, UUIDOID, 2951, bytes&lt;16&gt;)</div></div><!-- fragment --><p><code>OZO_PG_DEFINE_TYPE(CPP_TYPE, PG_TYPE, OID, SIZE)</code> defines a C++ to built-in PostgreSQL type mapping. It's arguments are:</p>
<ul>
<li><code>CPP_TYPE</code> - C++ type.</li>
<li><code>PG_TYPE</code> - PostgreSQL type name.</li>
<li><code>OID</code> - type OID in PostgreSQL.</li>
<li><code>SIZE</code> - type size which can be static for N bytes <code>bytes(N)</code>, or dynamic <code>dynamic_size</code>, like in this case.</li>
</ul>
<p><code>OZO_PG_DEFINE_TYPE_AND_ARRAY(CPP_TYPE, PG_TYPE, OID, ARRAY_OID SIZE)</code> defines C++ to built-in PostgreSQL type mapping with it's array. The current array represantation in OZO is std::vector, so for <code>uuid</code> type it will be <code>std::vector&lt;uuid&gt;</code>.</p>
<p>Since the mapping is <em><b>C++** to **PostgreSQL</b></em>, you can extend it with your own types.</p>
<p>E.g. we have a <code>text</code> type definition like:</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line">OZO_PG_DEFINE_TYPE_AND_ARRAY(std::string, &quot;text&quot;, TEXTOID, TEXTARRAYOID, dynamic_size)</div></div><!-- fragment --><p>You have your own brilliant string representation <code>Stroka</code> compatible with <code>const char* data(const Stroka&amp;)</code> and <code>const char* size(const Stroka&amp;)</code> functions (it is needed to use default introspection mechanisms). It can be included in type system and used as <code>text</code> representation like this:</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line">OZO_PG_DEFINE_TYPE_AND_ARRAY(Stroka, &quot;text&quot;, TEXTOID, TEXTARRAYOID, dynamic_size)</div></div><!-- fragment --><p>Now you can get <code>text</code> into <code>Stroka</code> type, and put <code>Stroka</code> object like text in queries. </p>
</div></div><!-- contents -->
<!-- Generated by DoxyPress 1.3.1 -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 23 2018 15:59:58 for OZO &nbsp; by &#160;<a href="http://www.copperspice.com/documentation-doxypress.html">
<img class="footer" src="doxypress.png" alt="DoxyPress"/></a> 1.3.1
</small></address>
</body>
</html>
